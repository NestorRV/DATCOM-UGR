error.test.arima2.2.0.H1 <- sum((pred.arima2.2.0.H1-test.noEst.H1)^2)
cat("error.test.arima2.2.0.H1:", error.test.arima2.2.0.H1, "\n")
plot.ts(train.noEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(6, 34))
lines(ajustados.arima2.2.0.H1, col = "blue")
lines(tiempo.test, test.noEst.H1, col = "red")
lines(tiempo.test, pred.arima2.2.0.H1, col = "blue")
# Ajustamos el modelo
arima0.0.1.H1 <- arima(train.noEst.H1, order = c(0, 0, 1))
ajustados.arima0.0.1.H1 <- train.noEst.H1 + arima0.0.1.H1$residuals
# Calculamos las predicciones
pred.arima0.0.1.H1 <- predict(arima0.0.1.H1, n.ahead = n.test)$pred
# Calculamos el error cuadrático acumulado del ajuste, en ajuste y en test
error.train.arima0.0.1.H1 <- sum((arima0.0.1.H1$residuals)^2)
cat("error.train.arima0.0.1.H1:", error.train.arima0.0.1.H1, "\n")
error.test.arima0.0.1.H1 <- sum((pred.arima0.0.1.H1-test.noEst.H1)^2)
cat("error.test.arima0.0.1.H1:", error.test.arima0.0.1.H1, "\n")
plot.ts(train.noEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(6, 34))
lines(ajustados.arima0.0.1.H1, col = "blue")
lines(tiempo.test, test.noEst.H1, col = "red")
lines(tiempo.test, pred.arima0.0.1.H1, col = "blue")
list(error.test.arima2.1.0.H1 = error.test.arima2.1.0.H1,
error.test.arima1.1.0.H1 = error.test.arima1.1.0.H1,
error.test.arima2.2.0.H1 = error.test.arima2.2.0.H1,
error.test.arima0.0.1.H1 = error.test.arima0.0.1.H1)
#Tests para la seccion del modelo y su validacion
box.pierce <- Box.test(arima0.0.1.H1$residuals)
box.pierce
#Test de normalidad de Jarque Bera
jbt <- jarque.bera.test(arima0.0.1.H1$residuals)
jbt
#Test de normalidad de Shaphiro-Wilk
saphiro <- shapiro.test(arima0.0.1.H1$residuals)
saphiro
#Test de normalidad de Jarque Bera
jbt <- jarque.bera.test(arima0.0.1.H1$residuals)
jbt
#Test de normalidad de Shaphiro-Wilk
saphiro <- shapiro.test(arima0.0.1.H1$residuals)
saphiro
list(error.test.arima1.1.0.H1 = error.test.arima1.1.0.H1,
error.test.arima2.2.0.H1 = error.test.arima2.2.0.H1,
error.test.arima0.0.1.H1 = error.test.arima0.0.1.H1)
knitr::opts_chunk$set(echo = TRUE, dpi=500)
library(imputeTS)
library(forecast)
library(tseries)
library(xts)
rm(list = ls(all = T))
serie <- read.csv("5530E.csv", sep = ";")
serie.ts <- ts(serie, frequency = 12)
sum(is.na(serie$Tmax))
serie <- imputeTS::na.ma(serie.ts)
serie.ts <- ts(serie, frequency = 12)
sum(is.na(serie))
# Agrupamos los datos por meses y nos quedamos sólo con la variable que
# representa la temeratura máxima, ya que es la que nos interesa
xts <- xts::xts(serie[,"Tmax"], order.by = as.Date(serie[,"Fecha"]), frequency = 1)
# El valor que vamos a tomar para un mes es la media de ese mes
serie <- xts::apply.monthly(xts, FUN = median)
# Convertimos los datos a una serie temporal
# Con los argumentos start = c(2013, 5) y end = c(2018, 2) indicamos que nuestra
# serie va a ser mensual. Esto lo podemos ver en los ejemplos de la documentación
# de la función ts: https://www.rdocumentation.org/packages/stats/versions/3.5.3/topics/ts
serie.ts <- ts(serie, frequency = 12, start = c(2013, 5), end = c(2018, 2))
plot.ts(serie.ts)
forecast::ggseasonplot(serie.ts, year.labels = T, year.labels.left = T)
plot(decompose(serie.ts))
n.test <- 12
train <- serie.ts[1:(length(serie.ts) - n.test)]
tiempo.train <- 1:length(train)
test <- serie.ts[(length(serie.ts) - n.test + 1):length(serie.ts)]
tiempo.test <- (tiempo.train[length(tiempo.train)] + 1):
(tiempo.train[length(tiempo.train)] + n.test)
plot.ts(train, xlim = c(1, tiempo.test[length(tiempo.test)]), ylim=c(0, 45))
lines(tiempo.test, test, col = "red")
parametros.H1 <- lm(train ~ tiempo.train)
#Calculamos la estimación de la tendencia.
TendEstimadaTr.H1 <- parametros.H1$coefficients[1]+tiempo.train*parametros.H1$coefficients[2]
TendEstimadaTs.H1 <- parametros.H1$coefficients[1]+tiempo.test*parametros.H1$coefficients[2]
#Mostramos en la misma figura la serie y la tendencia estimada
plot.ts(train, xlim=c(1, tiempo.test[length(tiempo.test)]))
lines(tiempo.train, TendEstimadaTr.H1, col="blue")
lines(tiempo.test, test, col="red")
lines(tiempo.test, TendEstimadaTs.H1, col="green")
#Test de normalidad de Jarque Bera
jarque.bera.test(parametros.H1$residuals)
jarque.bera.test((TendEstimadaTs.H1 - test))
#Test de Student
t.test(c(parametros.H1$residuals, TendEstimadaTs.H1-test))
train.SinTend.H1 <- train - TendEstimadaTr.H1
test.SinTend.H1 <- test - TendEstimadaTs.H1
plot.ts(train.SinTend.H1, xlim = c(1, tiempo.test[length(tiempo.test)]))
lines(tiempo.test, test.SinTend.H1, col = "red")
k <- 12
estacionalidad <- decompose(serie.ts)$seasonal[1:k]
# Eliminamos estacionalidad para el modelo
aux <- rep(estacionalidad, length(train) / length(estacionalidad))
train.noTendEst.H1 <- train.SinTend.H1 - aux
test.noTendEst.H1 <- test.SinTend.H1 - estacionalidad
plot.ts(train.noTendEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(-10, 10))
lines(tiempo.test, test.noTendEst.H1, col = "red")
# Comprobamos el test de Dickye-Fuller aumentado para la estacionaridad
adf <- adf.test(train.noTendEst.H1)
adf
# Diferenciamos la serie
train.noTendEstDiff.H1 <- diff(train.noTendEst.H1)
test.noTendEstDiff.H1 <- diff(test.noTendEst.H1)
# Volvemos a aplicar el test
adf <- adf.test(train.noTendEstDiff.H1)
adf
acf(train.noTendEstDiff.H1)
pacf(train.noTendEstDiff.H1)
# Ajustamos el modelo
arima1.1.0.H1 <- arima(train.noTendEst.H1, order = c(1, 1, 1))
ajustados.arima1.1.0.H1 <- train.noTendEst.H1 + arima1.1.0.H1$residuals
# Calculamos las predicciones
pred.arima1.1.0.H1 <- predict(arima1.1.0.H1, n.ahead = n.test)$pred
# Calculamos el error cuadrático acumulado del ajuste, en ajuste y en test
error.train.arima1.1.0.H1 <- sum((arima1.1.0.H1$residuals)^2)
cat("error.train.arima1.1.0.H1:", error.train.arima1.1.0.H1, "\n")
error.test.arima1.1.0.H1 <- sum((pred.arima1.1.0.H1-test.noTendEst.H1)^2)
cat("error.test.arima1.1.0.H1:", error.test.arima1.1.0.H1, "\n")
plot.ts(train.noTendEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(-11, 10))
lines(ajustados.arima1.1.0.H1, col = "blue")
lines(tiempo.test, test.noTendEst.H1, col = "red")
lines(tiempo.test, pred.arima1.1.0.H1, col = "blue")
par(mfrow=c(1,2))
acf(train.noTendEst.H1)
pacf(train.noTendEst.H1)
par(mfrow=c(1,2))
#Tests para la seccion del modelo y su validacion
box.pierce <- Box.test(arima1.1.0.H1$residuals)
box.pierce
#Test de normalidad de Jarque Bera
jbt <- jarque.bera.test(arima1.1.0.H1$residuals)
jbt
#Test de normalidad de Shaphiro-Wilk
saphiro <- shapiro.test(arima1.1.0.H1$residuals)
saphiro
hist(arima1.1.0.H1$residuals, col = "blue", prob = T, ylim=c(0, 0.2), xlim=c(-6, 6))
lines(density(arima1.1.0.H1$residuals))
# Ajustamos el modelo
arima2.2.0.H1 <- arima(train.noTendEst.H1, order = c(2, 2, 0))
ajustados.arima2.2.0.H1 <- train.noTendEst.H1 + arima2.2.0.H1$residuals
# Calculamos las predicciones
pred.arima2.2.0.H1 <- predict(arima2.2.0.H1, n.ahead = n.test)$pred
# Calculamos el error cuadrático acumulado del ajuste, en ajuste y en test
error.train.arima2.2.0.H1 <- sum((arima2.2.0.H1$residuals)^2)
cat("error.train.arima2.2.0.H1:", error.train.arima2.2.0.H1, "\n")
error.test.arima2.2.0.H1 <- sum((pred.arima2.2.0.H1-test.noTendEst.H1)^2)
cat("error.test.arima2.2.0.H1:", error.test.arima2.2.0.H1, "\n")
plot.ts(train.noTendEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(-10, 45))
lines(ajustados.arima2.2.0.H1, col = "blue")
lines(tiempo.test, test.noTendEst.H1, col = "red")
lines(tiempo.test, pred.arima2.2.0.H1, col = "blue")
# Ajustamos el modelo
arima0.0.1.H1 <- arima(train.noTendEst.H1, order = c(0, 0, 1))
ajustados.arima0.0.1.H1 <- train.noTendEst.H1 + arima0.0.1.H1$residuals
# Calculamos las predicciones
pred.arima0.0.1.H1 <- predict(arima0.0.1.H1, n.ahead = n.test)$pred
# Calculamos el error cuadrático acumulado del ajuste, en ajuste y en test
error.train.arima0.0.1.H1 <- sum((arima0.0.1.H1$residuals)^2)
cat("error.train.arima0.0.1.H1:", error.train.arima0.0.1.H1, "\n")
error.test.arima0.0.1.H1 <- sum((pred.arima0.0.1.H1-test.noTendEst.H1)^2)
cat("error.test.arima0.0.1.H1:", error.test.arima0.0.1.H1, "\n")
plot.ts(train.noTendEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(-15, 12))
lines(ajustados.arima0.0.1.H1, col = "blue")
lines(tiempo.test, test.noTendEst.H1, col = "red")
lines(tiempo.test, pred.arima0.0.1.H1, col = "blue")
list(error.test.arima1.1.0.H1 = error.test.arima1.1.0.H1,
error.test.arima2.2.0.H1 = error.test.arima2.2.0.H1,
error.test.arima0.0.1.H1 = error.test.arima0.0.1.H1)
#Tests para la seccion del modelo y su validacion
box.pierce <- Box.test(arima0.0.1.H1$residuals)
box.pierce
#Test de normalidad de Jarque Bera
jbt <- jarque.bera.test(arima0.0.1.H1$residuals)
jbt
#Test de normalidad de Shaphiro-Wilk
saphiro <- shapiro.test(arima0.0.1.H1$residuals)
saphiro
hist(arima0.0.1.H1$residuals, col = "blue", prob = T, ylim=c(0, 0.2), xlim=c(-11, 11))
lines(density(arima0.0.1.H1$residuals))
tiempo <- 1:length(serie.ts)
aux <- decompose(serie.ts)$seasonal
estacionalidad <- as.numeric(aux[1:12])
aux <- rep(estacionalidad, length(serie.ts) / length(estacionalidad))
serieSinEst <- serie.ts - aux
modelo <- arima(serieSinEst, order = c(0, 0, 1))
valoresAjustados <- serieSinEst + modelo$residuals
predicciones <- predict(modelo, n.ahead = 2)
# Cogemos las predicciones
valoresPredichos <- predicciones$pred
# Por ultimo, deshacemos lastacionalidad
valoresAjustados <- valoresAjustados + aux
# Cogemos los elementos 11:12 de la estacionalidad ya que son los asociados
# a los meses de marzo y abril, que son los meses que queremos predecir
valoresPredichos <- valoresPredichos + estacionalidad[11:12]
tiempoPred <- (tiempo[length(tiempo)]+(1:n.test))
plot.ts(serie.ts, xlim=c(2013.4, 2018.2), ylim=c(8, 34))
lines(valoresAjustados, col = "blue")
lines(valoresPredichos, col = "red")
tiempo <- 1:length(serie.ts)
aux <- decompose(serie.ts)$seasonal
estacionalidad <- as.numeric(aux[1:12])
aux <- rep(estacionalidad, length(serie.ts) / length(estacionalidad))
serieSinEst <- serie.ts - aux
modelo <- arima(serieSinEst, order = c(0, 0, 1))
valoresAjustados <- serieSinEst + modelo$residuals
predicciones <- predict(modelo, n.ahead = 2)
# Cogemos las predicciones
valoresPredichos <- predicciones$pred
# Por ultimo, deshacemos lastacionalidad
valoresAjustados <- valoresAjustados + aux
# Cogemos los elementos 11:12 de la estacionalidad ya que son los asociados
# a los meses de marzo y abril, que son los meses que queremos predecir
valoresPredichos <- valoresPredichos + estacionalidad[11:12]
tiempoPred <- (tiempo[length(tiempo)]+(1:n.test))
plot.ts(serie.ts, xlim=c(2013.4, 2018.2), ylim=c(8, 40))
lines(valoresAjustados, col = "blue")
lines(valoresPredichos, col = "red")
tiempo <- 1:length(serie.ts)
aux <- decompose(serie.ts)$seasonal
estacionalidad <- as.numeric(aux[1:12])
aux <- rep(estacionalidad, length(serie.ts) / length(estacionalidad))
serieSinEst <- serie.ts - aux
modelo <- arima(serieSinEst, order = c(0, 0, 1))
valoresAjustados <- serieSinEst + modelo$residuals
predicciones <- predict(modelo, n.ahead = 2)
# Cogemos las predicciones
valoresPredichos <- predicciones$pred
# Por ultimo, deshacemos lastacionalidad
valoresAjustados <- valoresAjustados + aux
# Cogemos los elementos 11:12 de la estacionalidad ya que son los asociados
# a los meses de marzo y abril, que son los meses que queremos predecir
valoresPredichos <- valoresPredichos + estacionalidad[11:12]
tiempoPred <- (tiempo[length(tiempo)]+(1:n.test))
plot.ts(serie.ts, xlim=c(2013.4, 2018.2), ylim=c(8, 45))
lines(valoresAjustados, col = "blue")
lines(valoresPredichos, col = "red")
plot.ts(decompose(serie.ts))
plot(decompose(serie.ts))
tiempo <- 1:length(serie.ts)
parametros <- lm(serie.ts ~ tiempo) #Ajustamos modelo de tendencia
TendEstimada <- parametros$coefficients[1] + tiempo * parametros$coefficients[2]
serieSinTend <- serie.ts - TendEstimada
aux <- decompose(serie.ts)$seasonal
estacionalidad <- as.numeric(aux[1:12])
aux <- rep(estacionalidad, length(serie.ts) / length(estacionalidad))
serieSinTendEst <- serieSinTend - aux
modelo <- arima(serieSinTend, order = c(0, 0, 1))
valoresAjustados <- serieSinTend + modelo$residuals
predicciones <- predict(modelo, n.ahead = 2)
# Cogemos las predicciones
valoresPredichos <- predicciones$pred
# Por ultimo, deshacemos lastacionalidad
valoresAjustados <- valoresAjustados + aux
# Cogemos los elementos 11:12 de la estacionalidad ya que son los asociados
# a los meses de marzo y abril, que son los meses que queremos predecir
valoresPredichos <- valoresPredichos + estacionalidad[11:12]
tiempoPred <- (tiempo[length(tiempo)]+(1:n.test))
plot.ts(serie.ts, xlim=c(2013.4, 2018.2), ylim=c(8, 45))
lines(valoresAjustados, col = "blue")
lines(valoresPredichos, col = "red")
tiempo <- 1:length(serie.ts)
parametros <- lm(serie.ts ~ tiempo) #Ajustamos modelo de tendencia
TendEstimada <- parametros$coefficients[1] + tiempo * parametros$coefficients[2]
serieSinTend <- serie.ts - TendEstimada
aux <- decompose(serie.ts)$seasonal
estacionalidad <- as.numeric(aux[1:12])
aux <- rep(estacionalidad, length(serie.ts) / length(estacionalidad))
serieSinTendEst <- serieSinTend - aux
modelo <- arima(serieSinTend, order = c(0, 0, 1))
valoresAjustados <- serieSinTend + modelo$residuals
predicciones <- predict(modelo, n.ahead = 2)
# Cogemos las predicciones
valoresPredichos <- predicciones$pred
# Por ultimo, deshacemos la estacionalidad
valoresAjustados <- valoresAjustados + aux
# Cogemos los elementos 11:12 de la estacionalidad ya que son los asociados
# a los meses de marzo y abril, que son los meses que queremos predecir
valoresPredichos <- valoresPredichos + estacionalidad[11:12]
valoresAjustados <- valoresAjustados + TendEstimada
tiempoPred <- (tiempo[length(tiempo)]+(1:NPred))
tiempo <- 1:length(serie.ts)
parametros <- lm(serie.ts ~ tiempo) #Ajustamos modelo de tendencia
TendEstimada <- parametros$coefficients[1] + tiempo * parametros$coefficients[2]
serieSinTend <- serie.ts - TendEstimada
aux <- decompose(serie.ts)$seasonal
estacionalidad <- as.numeric(aux[1:12])
aux <- rep(estacionalidad, length(serie.ts) / length(estacionalidad))
serieSinTendEst <- serieSinTend - aux
modelo <- arima(serieSinTend, order = c(0, 0, 1))
valoresAjustados <- serieSinTend + modelo$residuals
predicciones <- predict(modelo, n.ahead = 2)
# Cogemos las predicciones
valoresPredichos <- predicciones$pred
# Por ultimo, deshacemos la estacionalidad
valoresAjustados <- valoresAjustados + aux
# Cogemos los elementos 11:12 de la estacionalidad ya que son los asociados
# a los meses de marzo y abril, que son los meses que queremos predecir
valoresPredichos <- valoresPredichos + estacionalidad[11:12]
valoresAjustados <- valoresAjustados + TendEstimada
tiempoPred <- (tiempo[length(tiempo)]+(1:n.test))
TendEstimadaPred <- parametros$coefficients[1] + tiempoPred*parametros$coefficients[2]
valoresPredichos <- valoresPredichos + TendEstimadaPred
tiempoPred
TendEstimadaPred
length(TendEstimadaPred)
length(tiempoPred)
valoresPredichos
TendEstimadaPred
tiempo <- 1:length(serie.ts)
parametros <- lm(serie.ts ~ tiempo) #Ajustamos modelo de tendencia
TendEstimada <- parametros$coefficients[1] + tiempo * parametros$coefficients[2]
serieSinTend <- serie.ts - TendEstimada
aux <- decompose(serie.ts)$seasonal
estacionalidad <- as.numeric(aux[1:12])
aux <- rep(estacionalidad, length(serie.ts) / length(estacionalidad))
serieSinTendEst <- serieSinTend - aux
modelo <- arima(serieSinTend, order = c(0, 0, 1))
valoresAjustados <- serieSinTend + modelo$residuals
predicciones <- predict(modelo, n.ahead = 2)
# Cogemos las predicciones
valoresPredichos <- predicciones$pred
# Por ultimo, deshacemos la estacionalidad
valoresAjustados <- valoresAjustados + aux
# Cogemos los elementos 11:12 de la estacionalidad ya que son los asociados
# a los meses de marzo y abril, que son los meses que queremos predecir
valoresPredichos <- valoresPredichos + estacionalidad[11:12]
valoresAjustados <- valoresAjustados + TendEstimada
tiempoPred <- (tiempo[length(tiempo)]+(1:2))
TendEstimadaPred <- parametros$coefficients[1] + tiempoPred*parametros$coefficients[2]
valoresPredichos <- valoresPredichos + TendEstimadaPred
tiempoPred <- (tiempo[length(tiempo)]+(1:n.test))
plot.ts(serie.ts, xlim=c(2013.4, 2018.2), ylim=c(8, 45))
lines(valoresAjustados, col = "blue")
lines(valoresPredichos, col = "red")
forecast::ggseasonplot(serie.ts, year.labels = T, year.labels.left = T)
valoresPredichos
rm(list = ls(all = T))
tiempo <- 1:length(serie.ts)
tiempo <- 1:length(serie.ts)
knitr::opts_chunk$set(echo = TRUE, dpi=500)
library(imputeTS)
library(forecast)
library(tseries)
library(xts)
rm(list = ls(all = T))
serie <- read.csv("5530E.csv", sep = ";")
serie.ts <- ts(serie, frequency = 12)
sum(is.na(serie$Tmax))
serie <- imputeTS::na.ma(serie.ts)
serie.ts <- ts(serie, frequency = 12)
sum(is.na(serie))
# Agrupamos los datos por meses y nos quedamos sólo con la variable que
# representa la temeratura máxima, ya que es la que nos interesa
xts <- xts::xts(serie[,"Tmax"], order.by = as.Date(serie[,"Fecha"]), frequency = 1)
# El valor que vamos a tomar para un mes es la media de ese mes
serie <- xts::apply.monthly(xts, FUN = median)
# Convertimos los datos a una serie temporal
# Con los argumentos start = c(2013, 5) y end = c(2018, 2) indicamos que nuestra
# serie va a ser mensual. Esto lo podemos ver en los ejemplos de la documentación
# de la función ts: https://www.rdocumentation.org/packages/stats/versions/3.5.3/topics/ts
serie.ts <- ts(serie, frequency = 12, start = c(2013, 5), end = c(2018, 2))
plot.ts(serie.ts)
forecast::ggseasonplot(serie.ts, year.labels = T, year.labels.left = T)
plot(decompose(serie.ts))
n.test <- 12
train <- serie.ts[1:(length(serie.ts) - n.test)]
tiempo.train <- 1:length(train)
test <- serie.ts[(length(serie.ts) - n.test + 1):length(serie.ts)]
tiempo.test <- (tiempo.train[length(tiempo.train)] + 1):
(tiempo.train[length(tiempo.train)] + n.test)
plot.ts(train, xlim = c(1, tiempo.test[length(tiempo.test)]), ylim=c(0, 45))
lines(tiempo.test, test, col = "red")
parametros.H1 <- lm(train ~ tiempo.train)
#Calculamos la estimación de la tendencia.
TendEstimadaTr.H1 <- parametros.H1$coefficients[1]+tiempo.train*parametros.H1$coefficients[2]
TendEstimadaTs.H1 <- parametros.H1$coefficients[1]+tiempo.test*parametros.H1$coefficients[2]
#Mostramos en la misma figura la serie y la tendencia estimada
plot.ts(train, xlim=c(1, tiempo.test[length(tiempo.test)]))
lines(tiempo.train, TendEstimadaTr.H1, col="blue")
lines(tiempo.test, test, col="red")
lines(tiempo.test, TendEstimadaTs.H1, col="green")
#Test de normalidad de Jarque Bera
jarque.bera.test(parametros.H1$residuals)
jarque.bera.test((TendEstimadaTs.H1 - test))
#Test de Student
t.test(c(parametros.H1$residuals, TendEstimadaTs.H1-test))
train.SinTend.H1 <- train - TendEstimadaTr.H1
test.SinTend.H1 <- test - TendEstimadaTs.H1
plot.ts(train.SinTend.H1, xlim = c(1, tiempo.test[length(tiempo.test)]))
lines(tiempo.test, test.SinTend.H1, col = "red")
k <- 12
estacionalidad <- decompose(serie.ts)$seasonal[1:k]
# Eliminamos estacionalidad para el modelo
aux <- rep(estacionalidad, length(train) / length(estacionalidad))
train.noTendEst.H1 <- train.SinTend.H1 - aux
test.noTendEst.H1 <- test.SinTend.H1 - estacionalidad
plot.ts(train.noTendEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(-10, 10))
lines(tiempo.test, test.noTendEst.H1, col = "red")
# Comprobamos el test de Dickye-Fuller aumentado para la estacionaridad
adf <- adf.test(train.noTendEst.H1)
adf
# Diferenciamos la serie
train.noTendEstDiff.H1 <- diff(train.noTendEst.H1)
test.noTendEstDiff.H1 <- diff(test.noTendEst.H1)
# Volvemos a aplicar el test
adf <- adf.test(train.noTendEstDiff.H1)
adf
acf(train.noTendEstDiff.H1)
pacf(train.noTendEstDiff.H1)
# Ajustamos el modelo
arima1.1.0.H1 <- arima(train.noTendEst.H1, order = c(1, 1, 1))
ajustados.arima1.1.0.H1 <- train.noTendEst.H1 + arima1.1.0.H1$residuals
# Calculamos las predicciones
pred.arima1.1.0.H1 <- predict(arima1.1.0.H1, n.ahead = n.test)$pred
# Calculamos el error cuadrático acumulado del ajuste, en ajuste y en test
error.train.arima1.1.0.H1 <- sum((arima1.1.0.H1$residuals)^2)
cat("error.train.arima1.1.0.H1:", error.train.arima1.1.0.H1, "\n")
error.test.arima1.1.0.H1 <- sum((pred.arima1.1.0.H1-test.noTendEst.H1)^2)
cat("error.test.arima1.1.0.H1:", error.test.arima1.1.0.H1, "\n")
plot.ts(train.noTendEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(-11, 10))
lines(ajustados.arima1.1.0.H1, col = "blue")
lines(tiempo.test, test.noTendEst.H1, col = "red")
lines(tiempo.test, pred.arima1.1.0.H1, col = "blue")
par(mfrow=c(1,2))
acf(train.noTendEst.H1)
pacf(train.noTendEst.H1)
par(mfrow=c(1,2))
#Tests para la seccion del modelo y su validacion
box.pierce <- Box.test(arima1.1.0.H1$residuals)
box.pierce
#Test de normalidad de Jarque Bera
jbt <- jarque.bera.test(arima1.1.0.H1$residuals)
jbt
#Test de normalidad de Shaphiro-Wilk
saphiro <- shapiro.test(arima1.1.0.H1$residuals)
saphiro
hist(arima1.1.0.H1$residuals, col = "blue", prob = T, ylim=c(0, 0.2), xlim=c(-6, 6))
lines(density(arima1.1.0.H1$residuals))
# Ajustamos el modelo
arima2.2.0.H1 <- arima(train.noTendEst.H1, order = c(2, 2, 0))
ajustados.arima2.2.0.H1 <- train.noTendEst.H1 + arima2.2.0.H1$residuals
# Calculamos las predicciones
pred.arima2.2.0.H1 <- predict(arima2.2.0.H1, n.ahead = n.test)$pred
# Calculamos el error cuadrático acumulado del ajuste, en ajuste y en test
error.train.arima2.2.0.H1 <- sum((arima2.2.0.H1$residuals)^2)
cat("error.train.arima2.2.0.H1:", error.train.arima2.2.0.H1, "\n")
error.test.arima2.2.0.H1 <- sum((pred.arima2.2.0.H1-test.noTendEst.H1)^2)
cat("error.test.arima2.2.0.H1:", error.test.arima2.2.0.H1, "\n")
plot.ts(train.noTendEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(-10, 45))
lines(ajustados.arima2.2.0.H1, col = "blue")
lines(tiempo.test, test.noTendEst.H1, col = "red")
lines(tiempo.test, pred.arima2.2.0.H1, col = "blue")
# Ajustamos el modelo
arima0.0.1.H1 <- arima(train.noTendEst.H1, order = c(0, 0, 1))
ajustados.arima0.0.1.H1 <- train.noTendEst.H1 + arima0.0.1.H1$residuals
# Calculamos las predicciones
pred.arima0.0.1.H1 <- predict(arima0.0.1.H1, n.ahead = n.test)$pred
# Calculamos el error cuadrático acumulado del ajuste, en ajuste y en test
error.train.arima0.0.1.H1 <- sum((arima0.0.1.H1$residuals)^2)
cat("error.train.arima0.0.1.H1:", error.train.arima0.0.1.H1, "\n")
error.test.arima0.0.1.H1 <- sum((pred.arima0.0.1.H1-test.noTendEst.H1)^2)
cat("error.test.arima0.0.1.H1:", error.test.arima0.0.1.H1, "\n")
plot.ts(train.noTendEst.H1, xlim=c(1, tiempo.test[length(tiempo.test)]), ylim=c(-15, 12))
lines(ajustados.arima0.0.1.H1, col = "blue")
lines(tiempo.test, test.noTendEst.H1, col = "red")
lines(tiempo.test, pred.arima0.0.1.H1, col = "blue")
list(error.test.arima1.1.0.H1 = error.test.arima1.1.0.H1,
error.test.arima2.2.0.H1 = error.test.arima2.2.0.H1,
error.test.arima0.0.1.H1 = error.test.arima0.0.1.H1)
#Tests para la seccion del modelo y su validacion
box.pierce <- Box.test(arima0.0.1.H1$residuals)
box.pierce
#Test de normalidad de Jarque Bera
jbt <- jarque.bera.test(arima0.0.1.H1$residuals)
jbt
#Test de normalidad de Shaphiro-Wilk
saphiro <- shapiro.test(arima0.0.1.H1$residuals)
saphiro
hist(arima0.0.1.H1$residuals, col = "blue", prob = T, ylim=c(0, 0.2), xlim=c(-11, 11))
lines(density(arima0.0.1.H1$residuals))
tiempo <- 1:length(serie.ts)
parametros <- lm(serie.ts ~ tiempo) #Ajustamos modelo de tendencia
TendEstimada <- parametros$coefficients[1] + tiempo * parametros$coefficients[2]
serieSinTend <- serie.ts - TendEstimada
aux <- decompose(serie.ts)$seasonal
estacionalidad <- as.numeric(aux[1:12])
aux <- rep(estacionalidad, length(serie.ts) / length(estacionalidad))
serieSinTendEst <- serieSinTend - aux
modelo <- arima(serieSinTend, order = c(0, 0, 1))
valoresAjustados <- serieSinTend + modelo$residuals
predicciones <- predict(modelo, n.ahead = 2)
# Cogemos las predicciones
valoresPredichos <- predicciones$pred
# Por ultimo, deshacemos la estacionalidad
valoresAjustados <- valoresAjustados + aux
# Cogemos los elementos 11:12 de la estacionalidad ya que son los asociados
# a los meses de marzo y abril, que son los meses que queremos predecir
valoresPredichos <- valoresPredichos + estacionalidad[11:12]
valoresAjustados <- valoresAjustados + TendEstimada
tiempoPred <- (tiempo[length(tiempo)]+(1:2))
TendEstimadaPred <- parametros$coefficients[1] + tiempoPred*parametros$coefficients[2]
valoresPredichos <- valoresPredichos + TendEstimadaPred
tiempoPred <- (tiempo[length(tiempo)]+(1:n.test))
plot.ts(serie.ts, xlim=c(2013.4, 2018.2), ylim=c(8, 47))
lines(valoresAjustados, col = "blue")
lines(valoresPredichos, col = "red")
forecast::ggseasonplot(serie.ts, year.labels = T, year.labels.left = T)
valoresPredichos
